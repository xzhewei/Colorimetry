function temp = xy2cct(x,y)
% 这个方法用黑体和D验证大概误差在30K以下
persistent uvk rt
if isempty(uvk)
    [rt,uvk] = initdata();
end
u = 4*x/(-2*x+12*y+3);  %需要计算的
v = 6*y/(-2*x+12*y+3);  %色坐标点
%uo        %黑体轨迹
%vo        %上的色坐标
uo = uvk(:,1);
vo = uvk(:,2);
m = uvk(:,3);

dm = 0;   %待测色坐标点到最高色温线的距离
temp=0;
for i = 1:size(rt)
    di = (v-vo(i)) - m(i)*(u-uo(i));
    if i>0 && ((di<0 && dm>=0) || (di>=0 && dm<0))
        dm = dm/sqrt(1+m(i-1)^2);
        di = di/sqrt(1+m(i)^2);
        temp = 1/(rt(i-1) + dm/(dm-di)*(rt(i) - rt(i-1)));
        temp = 1.4388/1.4380*temp;
        break;
    else
        dm = di;
        continue;
    end
end

end

function [rt,uvk] = initdata()
rt = [0;1;2;3;4;5;6;7;8;9;10;12.5;15;17.5;20;22.5;25;27.5;30;...
    32.5;35;37.5;40;42.5;45;47.5;50;52.5;55;57.5;60];
rt = rt*10^-5;
uvk = [0.18006, 0.26352, -0.24341;
    0.18066, 0.26589, -0.25479;
    0.18133, 0.26846, -0.26876;
    0.18208, 0.27119, -0.28539;
    0.18293, 0.27407, -0.30470;
    0.18388, 0.27709, -0.32675;
    0.18494, 0.28021, -0.35156;
    0.18611, 0.28342, -0.37915;
    0.18740, 0.28668, -0.40955;
    0.18880, 0.28997, -0.44278;
    0.19032, 0.29326, -0.47888;
    0.19462, 0.30141, -0.58204;
    0.19962, 0.30921, -0.70471;
    0.20525, 0.31647, -0.84901;
    0.21142, 0.32312, -1.0182;
    0.21807, 0.32909, -1.2168;
    0.22511, 0.33439, -1.4512;
    0.23247, 0.33904, -1.7298;
    0.24010, 0.34308, -2.0637;
    0.24792, 0.34655, -2.4681;
    0.25591, 0.34951, -2.9641;
    0.26400, 0.35200, -3.5814;
    0.27218, 0.35407, -4.3633;
    0.28039, 0.35577, -5.3762;
    0.28863, 0.35714, -6.7262;
    0.29685, 0.35823, -8.5955;
    0.30505, 0.35907, -11.324;
    0.31320, 0.35968, -15.628;
    0.32129, 0.36011, -23.325;
    0.32931, 0.36038, -40.770;
    0.33724, 0.36051, -116.45];
end